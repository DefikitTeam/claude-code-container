@startuml Infrastructure Layer Design
!include ../_style-common.puml

title Infrastructure Layer - Cloudflare Workers Implementation

package "infrastructure/" <<Folder>> #2ecc71 {
  
  package "durable-objects/" <<Folder>> {
    class UserConfigDO {
      -ctx: DurableObjectState
      -env: Env
      -encryptionKey: CryptoKey
      --
      +fetch(request: Request): Promise<Response>
      +save(user: UserEntity): Promise<void>
      +findById(id: string): Promise<UserEntity | null>
      +findByInstallationId(id: string): Promise<UserEntity | null>
      +findAll(): Promise<UserEntity[]>
      +delete(id: string): Promise<void>
      --
      -getEncryptionKey(): Promise<CryptoKey>
      -encrypt(data: string): Promise<EncryptedData>
      -decrypt(data: EncryptedData): Promise<string>
    }
    note right: ~350 LOC\n(implements IUserRepository)
    
    class GitHubAppConfigDO {
      -ctx: DurableObjectState
      -env: Env
      -encryptionKey: CryptoKey
      --
      +fetch(request: Request): Promise<Response>
      +storeConfig(config: GitHubAppConfig): Promise<void>
      +retrieveConfig(): Promise<GitHubAppConfig>
      +updateInstallationToken(token: string): Promise<void>
      +clearConfig(): Promise<void>
      --
      -encryptSensitiveData(data: string): Promise<EncryptedData>
    }
    note right: ~300 LOC
    
    class ACPSessionDO {
      -ctx: DurableObjectState
      -env: Env
      -activeSession: ACPSession | null
      --
      +fetch(request: Request): Promise<Response>
      +createSession(config: SessionConfig): Promise<string>
      +sendMessage(sessionId: string, msg: Message): Promise<Response>
      +getStatus(sessionId: string): Promise<SessionStatus>
      +cancelSession(sessionId: string): Promise<void>
      --
      -initializeSession(config: SessionConfig): Promise<void>
      -cleanupSession(): Promise<void>
    }
    note right: ~400 LOC
    
    class ContainerDO {
      -ctx: DurableObjectState
      -env: Env
      -container: Container | null
      --
      +fetch(request: Request): Promise<Response>
      +spawn(config: ContainerConfig): Promise<string>
      +execute(command: string): Promise<ExecutionResult>
      +getLogs(): Promise<string[]>
      +terminate(): Promise<void>
      --
      -prepareEnvironment(config: ContainerConfig): Promise<EnvVars>
      -handleContainerOutput(stream: ReadableStream): Promise<void>
    }
    note right: ~450 LOC\n(implements IContainerService)
  }
  
  package "services/" <<Folder>> {
    class GitHubServiceImpl {
      -tokenManager: TokenManager
      -appConfig: GitHubAppConfig
      --
      +validateInstallation(id: string): Promise<boolean>
      +getRepositories(installationId: string): Promise<Repository[]>
      +getBranches(owner: string, repo: string): Promise<Branch[]>
      +createPullRequest(dto: CreatePRDto): Promise<PullRequest>
      +createIssue(dto: CreateIssueDto): Promise<Issue>
      --
      -getOctokit(installationId: string): Promise<Octokit>
      -handleRateLimiting(): Promise<void>
    }
    note right: ~280 LOC\n(implements IGitHubService)
    
    class TokenServiceImpl {
      -tokenManager: TokenManager
      -cache: Map<string, TokenCache>
      --
      +getInstallationToken(id: string): Promise<string>
      +refreshToken(id: string): Promise<string>
      +validateToken(token: string): Promise<boolean>
      --
      -isTokenExpired(token: TokenCache): boolean
      -refreshIfNeeded(id: string): Promise<string>
    }
    note right: ~200 LOC\n(implements ITokenService)
    
    class CryptoServiceImpl {
      -encryptionKey: CryptoKey
      --
      +encrypt(data: string): Promise<string>
      +decrypt(encrypted: string): Promise<string>
      +hash(data: string): Promise<string>
      --
      -generateKey(): Promise<CryptoKey>
      -exportKey(key: CryptoKey): Promise<ArrayBuffer>
      -importKey(keyData: ArrayBuffer): Promise<CryptoKey>
    }
    note right: ~180 LOC\n(implements ICryptoService)
    
    class DeploymentServiceImpl {
      -cloudflareApi: CloudflareAPI
      -wranglerWrapper: WranglerWrapper
      --
      +deploy(config: DeploymentConfig): Promise<DeploymentResult>
      +getStatus(deploymentId: string): Promise<DeploymentStatus>
      +rollback(deploymentId: string): Promise<void>
      --
      -uploadWorker(code: string): Promise<string>
      -updateSecrets(secrets: Record<string, string>): Promise<void>
      -verifyDeployment(workerId: string): Promise<boolean>
    }
    note right: ~340 LOC\n(implements IDeploymentService)
  }
  
  package "repositories/" <<Folder>> {
    class DeploymentRepositoryImpl {
      -durableObject: DurableObjectNamespace
      --
      +save(deployment: DeploymentEntity): Promise<void>
      +findById(id: string): Promise<DeploymentEntity | null>
      +findByUserId(userId: string): Promise<DeploymentEntity[]>
      +update(id: string, updates: Partial<DeploymentEntity>): Promise<void>
      --
      -toDurableObject(entity: DeploymentEntity): StoredDeployment
      -toEntity(stored: StoredDeployment): DeploymentEntity
    }
    note right: ~150 LOC\n(implements IDeploymentRepository)
  }
  
  package "adapters/" <<Folder>> {
    class CloudflareAPIAdapter {
      -apiToken: string
      -accountId: string
      --
      +deployWorker(config: WorkerConfig): Promise<DeploymentResult>
      +updateDurableObjects(config: DOConfig): Promise<void>
      +uploadAssets(assets: Asset[]): Promise<void>
      +getWorkerLogs(workerId: string): Promise<LogEntry[]>
    }
    note right: ~200 LOC
    
    class WranglerWrapper {
      --
      +deploy(configPath: string): Promise<DeploymentResult>
      +publish(manifest: Manifest): Promise<string>
      +tail(workerId: string): Promise<ReadableStream>
    }
    note right: ~100 LOC
  }
  
  package "external/" <<Folder>> {
    class TokenManager {
      -appId: string
      -privateKey: string
      -tokenCache: Map<string, TokenCache>
      --
      +getInstallationToken(installationId: string): Promise<string>
      +refreshToken(installationId: string): Promise<string>
      +createJWT(): string
      --
      -executeWithRetry<T>(fn: () => Promise<T>): Promise<T>
      -handleRateLimiting(response: Response): Promise<void>
    }
    note right: ~500 LOC\n(existing, refactored)
  }
}

note bottom
  **Infrastructure Layer Summary:**
  - Total: ~2,800 LOC
  - Durable Objects: ~1,500 LOC (4 classes)
  - Services: ~1,000 LOC (4 classes)
  - Repositories: ~150 LOC (1 class)
  - Adapters: ~300 LOC (2 classes)
  - External: ~500 LOC (TokenManager)
  
  **Characteristics:**
  - Implements Core interfaces
  - Cloudflare-specific code
  - External API integrations
  - Infrastructure concerns
  - Can be swapped/mocked easily
end note

@enduml
