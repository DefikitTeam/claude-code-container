@startuml Error Handling Strategy
!include ../_style-common.puml

title Error Handling & Propagation Through Layers

package "Error Types" <<Rectangle>> #9b59b6 {
  
  abstract class BaseError {
    +name: string
    +message: string
    +statusCode: number
    +isOperational: boolean
    --
    +toJSON(): ErrorResponse
  }
  
  class ValidationError {
    +statusCode: 400
    +fields: ValidationField[]
    --
    +addField(field, message): void
  }
  
  class NotFoundError {
    +statusCode: 404
    +resourceType: string
    +resourceId: string
  }
  
  class UnauthorizedError {
    +statusCode: 401
    +reason: string
  }
  
  class ForbiddenError {
    +statusCode: 403
    +resource: string
    +action: string
  }
  
  class ConflictError {
    +statusCode: 409
    +conflictingResource: string
  }
  
  class InternalError {
    +statusCode: 500
    +isOperational: false
    +originalError: Error
  }
  
  class ExternalServiceError {
    +statusCode: 502
    +service: string
    +originalError: Error
  }
  
  ValidationError --|> BaseError
  NotFoundError --|> BaseError
  UnauthorizedError --|> BaseError
  ForbiddenError --|> BaseError
  ConflictError --|> BaseError
  InternalError --|> BaseError
  ExternalServiceError --|> BaseError
}

package "Error Handling Flow" {
  
  participant "External API" as External #95a5a6
  participant "Service\nImplementation" as Service #2ecc71
  participant "Use Case" as UseCase #3498db
  participant "Controller" as Controller #f39c12
  participant "Error Middleware" as ErrorMW #f39c12
  participant "Client" as Client
  
  == External Service Error ==
  
  Service -> External: API Call
  activate Service
  activate External
  
  External --> Service: ❌ 503 Service Unavailable
  deactivate External
  
  Service -> Service: Catch error
  Service -> Service: throw new ExternalServiceError(\n  "GitHub API unavailable",\n  originalError\n)
  
  Service --> UseCase: ⚠️ ExternalServiceError
  deactivate Service
  activate UseCase
  
  UseCase -> UseCase: Catch error
  UseCase -> UseCase: Add context:\n"Failed to fetch repositories"
  
  UseCase --> Controller: ⚠️ ExternalServiceError\n(with context)
  deactivate UseCase
  activate Controller
  
  Controller -> Controller: Don't catch\n(let middleware handle)
  
  Controller --> ErrorMW: ⚠️ ExternalServiceError
  deactivate Controller
  activate ErrorMW
  
  ErrorMW -> ErrorMW: Check error type
  ErrorMW -> ErrorMW: Log error\n(with stack trace)
  ErrorMW -> ErrorMW: Format response:\n{\n  "success": false,\n  "error": "ExternalServiceError",\n  "message": "GitHub API unavailable",\n  "statusCode": 502\n}
  
  ErrorMW --> Client: HTTP 502\n{"success": false, ...}
  deactivate ErrorMW
  
  == Validation Error ==
  
  Client -> Controller: POST /user/register\n{"userId": "", "installationId": "invalid"}
  activate Controller
  
  Controller -> UseCase: execute(dto)
  activate UseCase
  
  UseCase -> UseCase: Validate DTO
  UseCase -> UseCase: throw new ValidationError(\n  "Invalid input"\n)\n.addField("userId", "Required")\n.addField("installationId", "Invalid format")
  
  UseCase --> Controller: ⚠️ ValidationError
  deactivate UseCase
  
  Controller --> ErrorMW: ⚠️ ValidationError
  deactivate Controller
  activate ErrorMW
  
  ErrorMW -> ErrorMW: Format validation errors:\n{\n  "success": false,\n  "error": "ValidationError",\n  "message": "Invalid input",\n  "statusCode": 400,\n  "details": {\n    "fields": [\n      {"field": "userId", "message": "Required"},\n      {"field": "installationId", "message": "Invalid format"}\n    ]\n  }\n}
  
  ErrorMW --> Client: HTTP 400\n{"success": false, ...}
  deactivate ErrorMW
  
  == Not Found Error ==
  
  Client -> Controller: GET /user/999
  activate Controller
  
  Controller -> UseCase: execute(userId)
  activate UseCase
  
  UseCase -> UseCase: Check if user exists
  UseCase -> UseCase: throw new NotFoundError(\n  "User",\n  "999"\n)
  
  UseCase --> Controller: ⚠️ NotFoundError
  deactivate UseCase
  
  Controller --> ErrorMW: ⚠️ NotFoundError
  deactivate Controller
  activate ErrorMW
  
  ErrorMW -> ErrorMW: Format:\n{\n  "success": false,\n  "error": "NotFoundError",\n  "message": "User with ID 999 not found",\n  "statusCode": 404\n}
  
  ErrorMW --> Client: HTTP 404
  deactivate ErrorMW
  
  == Unexpected Error ==
  
  Client -> Controller: POST /container/spawn
  activate Controller
  
  Controller -> UseCase: execute(dto)
  activate UseCase
  
  UseCase -> UseCase: Unexpected error:\nTypeError: Cannot read property 'x' of undefined
  
  UseCase --> Controller: ⚠️ TypeError
  deactivate UseCase
  
  Controller --> ErrorMW: ⚠️ TypeError
  deactivate Controller
  activate ErrorMW
  
  ErrorMW -> ErrorMW: Check if operational error
  ErrorMW -> ErrorMW: isOperational = false
  ErrorMW -> ErrorMW: Log full stack trace\n(for debugging)
  ErrorMW -> ErrorMW: Wrap in InternalError
  ErrorMW -> ErrorMW: Format safe response:\n{\n  "success": false,\n  "error": "InternalError",\n  "message": "An unexpected error occurred",\n  "statusCode": 500\n}\n(hide details from client)
  
  ErrorMW --> Client: HTTP 500\n{"success": false, ...}
  deactivate ErrorMW
}

note bottom
  **Error Handling Strategy:**
  
  **Operational Errors** (expected):
  - ValidationError (400)
  - NotFoundError (404)
  - UnauthorizedError (401)
  - ForbiddenError (403)
  - ConflictError (409)
  - ExternalServiceError (502)
  
  → Return detailed error to client
  → Log for monitoring
  
  **Non-Operational Errors** (bugs):
  - TypeError, ReferenceError, etc.
  - Unexpected exceptions
  
  → Return generic error to client
  → Log full stack trace
  → Alert developers
  
  **Layer Responsibilities:**
  
  1. **Infrastructure Layer:**
     - Catch external service errors
     - Throw ExternalServiceError
     - Add service context
  
  2. **Core Layer:**
     - Validate business rules
     - Throw domain-specific errors
     - Add business context
  
  3. **API Layer (Controllers):**
     - Don't catch errors
     - Let middleware handle
  
  4. **API Layer (Middleware):**
     - Catch ALL errors
     - Format responses
     - Log appropriately
     - Return HTTP status codes
  
  **Benefits:**
  - Consistent error responses
  - Clear error classification
  - Proper logging
  - Client-safe error messages
  - Easy to debug
end note

@enduml
