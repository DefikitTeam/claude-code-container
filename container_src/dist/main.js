import http from 'node:http';
import { URL } from 'node:url';
import { promises as fs } from 'node:fs';
import path from 'node:path';
import os from 'node:os';
import simpleGit from 'simple-git';
import { execFile } from 'node:child_process';
import { promisify } from 'node:util';
import dotenv from 'dotenv';
import { query } from '@anthropic-ai/claude-code';
import { ContainerGitHubClient } from './github_client.js';
import { runAcp } from './zed-acp-agent.js';
import { runGenericAcp } from './generic-acp-agent.js';
// Load environment variables - suppress output in test environment
if (process.env.NODE_ENV !== 'test') {
    dotenv.config();
}
const PORT = parseInt(process.env.PORT || '8080', 10);
const INSTANCE_ID = process.env.CONTAINER_ID || 'unknown';
// Determine runtime mode based on environment and command line arguments
function determineRuntimeMode() {
    // Check command line arguments
    const args = process.argv.slice(2);
    if (args.includes('--acp') || args.includes('--stdio')) {
        return 'acp';
    }
    if (args.includes('--generic-acp') || args.includes('--agent-server')) {
        return 'generic-acp';
    }
    // Check environment variable
    const acpMode = process.env.ACP_MODE?.toLowerCase();
    if (acpMode === 'stdio' || acpMode === 'acp') {
        return 'acp';
    }
    if (acpMode === 'generic' || acpMode === 'agent-server') {
        return 'generic-acp';
    }
    // Default to HTTP mode
    return 'http';
}
function logWithContext(context, message, data) {
    const ts = new Date().toISOString();
    if (data)
        console.log(`[${ts}] [${context}] ${message}`, JSON.stringify(data, null, 2));
    else
        console.log(`[${ts}] [${context}] ${message}`);
}
const pExecFile = promisify(execFile);
async function checkRuntime() {
    const out = {
        node: process.version,
        apiKey: !!process.env.ANTHROPIC_API_KEY,
        githubToken: !!process.env.GITHUB_TOKEN
    };
    try {
        const { stdout } = await pExecFile('git', ['--version']);
        out.git = stdout.trim();
    }
    catch { }
    try {
        const { stdout } = await pExecFile('bash', ['--version']);
        out.bash = stdout.split('\n')[0].trim();
    }
    catch { }
    logWithContext('RUNTIME', 'Environment check', out);
    return out;
}
function prepareClaudePrompt(issueContext, repoSummary = null) {
    return `
You are working on GitHub issue #${issueContext.issueNumber}: "${issueContext.title}"

Issue Description:
${issueContext.description}

Labels: ${issueContext.labels.join(', ')}
Author: ${issueContext.author}

The repository has been cloned to your current working directory. Please:
1. Explore the codebase to understand the structure and relevant files
2. Analyze the issue requirements thoroughly
3. Implement a solution that addresses the issue
4. Write appropriate tests if needed
5. Ensure code quality and consistency with existing patterns

**IMPORTANT: If you make any file changes, please create a file called '.claude-pr-summary.md' in the root directory with a concise summary (1-3 sentences) of what changes you made and why. This will be used for the pull request description.**

Work step by step and provide clear explanations of your approach.
${repoSummary ? `\n\nRepository summary:\n${repoSummary}` : ''}
`;
}
function getMessageText(message) {
    // @ts-ignore
    if (typeof message.text === 'string')
        return message.text;
    // @ts-ignore
    if (typeof message.content === 'string')
        return message.content;
    // @ts-ignore
    if (Array.isArray(message.content))
        return message.content.map((c) => (c.text || JSON.stringify(c))).join('\n');
    return JSON.stringify(message);
}
async function detectGitChanges(workspaceDir) {
    const git = simpleGit(workspaceDir);
    try {
        const status = await git.status();
        return !status.isClean();
    }
    catch (e) {
        logWithContext('GIT', 'detectGitChanges failed', { workspaceDir, error: e.message });
        return false;
    }
}
async function createFeatureBranchCommitAndPush(workspaceDir, branchName, message) {
    const git = simpleGit(workspaceDir);
    await git.checkoutLocalBranch(branchName);
    await git.add('.');
    const result = await git.commit(message);
    await git.push('origin', branchName, ['--set-upstream']);
    return result.commit;
}
async function readPRSummary(workspaceDir) {
    const summaryPath = path.join(workspaceDir, '.claude-pr-summary.md');
    try {
        const content = await fs.readFile(summaryPath, 'utf8');
        return content.trim();
    }
    catch {
        return null;
    }
}
function generatePRBody(prSummary, solution, issueNumber) {
    let body = '';
    if (prSummary)
        body = prSummary.trim();
    else
        body = 'Automated fix generated by Claude Code.';
    body += `\n\n---\nFixes #${issueNumber}\n\nðŸ¤– This pull request was generated automatically by Claude Code.`;
    body += `\n\n\n**Solution proposed:**\n${solution}`;
    return body;
}
async function getRequestBody(req) {
    let body = '';
    for await (const chunk of req)
        body += chunk.toString();
    return body;
}
async function setupWorkspace(cloneUrl, githubToken) {
    const workspaceDir = path.join(os.tmpdir(), `claude-workspace-${Date.now()}`);
    await fs.mkdir(workspaceDir, { recursive: true });
    logWithContext('WORKSPACE', 'Cloning repository', { cloneUrl, workspaceDir });
    const git = simpleGit();
    const token = githubToken || process.env.GITHUB_TOKEN;
    const authenticated = token ? cloneUrl.replace('https://github.com/', `https://x-access-token:${token}@github.com/`) : cloneUrl;
    await git.clone(authenticated, workspaceDir, ['--depth', '1']);
    // Configure Git user identity in the workspace
    const workspaceGit = simpleGit(workspaceDir);
    await workspaceGit.addConfig('user.name', 'Claude Code Bot');
    await workspaceGit.addConfig('user.email', 'claude-code@anthropic.com');
    logWithContext('WORKSPACE', 'Git user identity configured');
    return workspaceDir;
}
async function cleanupWorkspace(dir) {
    try {
        await fs.rm(dir, { recursive: true, force: true });
        logWithContext('WORKSPACE', 'Cleaned up', { dir });
    }
    catch (e) {
        logWithContext('WORKSPACE', 'Cleanup failed', { dir, error: e.message });
    }
}
async function processIssue(issueContext, githubToken) {
    const results = [];
    let turnCount = 0;
    try {
        // Ensure runtime dependencies are available
        const rt = await checkRuntime();
        if (!rt.apiKey) {
            return { success: false, message: 'Missing Anthropic API key (ANTHROPIC_API_KEY)' };
        }
        if (!rt.git) {
            return { success: false, message: 'git is not available in the container PATH' };
        }
        const workspaceDir = await setupWorkspace(issueContext.repositoryUrl, githubToken);
        const [owner, repo] = issueContext.repositoryName.split('/');
        const githubClient = new ContainerGitHubClient(githubToken, owner, repo);
        const prompt = prepareClaudePrompt(issueContext);
        logWithContext('ISSUE_PROCESSOR', 'Prompt prepared', { length: prompt.length });
        const originalCwd = process.cwd();
        process.chdir(workspaceDir);
        let solution = 'No solution generated.';
        try {
            // Enable verbose SDK debug logs if not already set
            if (!process.env.DEBUG)
                process.env.DEBUG = 'claude-code:*';
            logWithContext('CLAUDE', 'Starting Claude Code SDK', { apiKeyExists: !!process.env.ANTHROPIC_API_KEY });
            for await (const message of query({ prompt, options: { permissionMode: 'bypassPermissions' } })) {
                turnCount++;
                results.push(message);
                logWithContext('CLAUDE', `Turn ${turnCount}`, { type: message.type });
            }
            solution = results.length > 0 ? getMessageText(results[results.length - 1]) : 'No solution generated.';
        }
        catch (sdkError) {
            logWithContext('CLAUDE', 'Claude Code SDK error', { error: sdkError?.message || String(sdkError), stack: sdkError?.stack });
            try {
                await githubClient.createComment(parseInt(issueContext.issueNumber), [
                    'âš ï¸ Claude Code failed in the container.',
                    '',
                    `Error: ${sdkError?.message || String(sdkError)}`,
                    '',
                    'Checklist:',
                    `- ANTHROPIC_API_KEY present: ${rt.apiKey ? 'yes' : 'no'}`,
                    `- git available: ${rt.git ? rt.git : 'no'}`,
                    `- bash available: ${rt.bash ? rt.bash : 'no'}`,
                    `- node: ${rt.node}`,
                    '',
                    'Please check container logs for claude-code debug output (DEBUG=claude-code:*).'
                ].join('\n'));
            }
            catch (commentErr) {
                logWithContext('CLAUDE', 'Failed to post SDK error comment', { error: commentErr.message });
            }
            await cleanupWorkspace(workspaceDir);
            return { success: false, message: 'Claude Code process exited with code 1' };
        }
        finally {
            process.chdir(originalCwd);
        }
        const hasChanges = await detectGitChanges(workspaceDir);
        if (hasChanges) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').replace(/T/g, '-').split('.')[0];
            const branchName = `claude-code/issue-${issueContext.issueNumber}-${timestamp}`;
            await createFeatureBranchCommitAndPush(workspaceDir, branchName, `Fix issue #${issueContext.issueNumber}: ${issueContext.title}`);
            const prSummary = await readPRSummary(workspaceDir);
            const repoInfo = await githubClient.getRepository();
            const prTitle = prSummary ? prSummary.split('\n')[0].trim() : `Fix issue #${issueContext.issueNumber}`;
            const prBody = generatePRBody(prSummary, solution, issueContext.issueNumber);
            const pullRequest = await githubClient.createPullRequest(prTitle, prBody, branchName, repoInfo.default_branch);
            await cleanupWorkspace(workspaceDir);
            await githubClient.createComment(parseInt(issueContext.issueNumber), `ðŸ”§ Created PR: ${pullRequest.html_url}`);
            return { success: true, message: 'Pull request created', pullRequestUrl: pullRequest.html_url };
        }
        else {
            await githubClient.createComment(parseInt(issueContext.issueNumber), `${solution}\n\n---\nðŸ¤– Generated with Claude Code`);
            await cleanupWorkspace(workspaceDir);
            return { success: true, message: 'Comment posted (no file changes)' };
        }
    }
    catch (error) {
        return { success: false, message: 'Processing failed', error: error.message };
    }
}
async function processIssueHandler(req, res) {
    const startTime = Date.now();
    logWithContext('PROCESS', 'Starting issue processing', { timestamp: new Date().toISOString() });
    try {
        const body = await getRequestBody(req);
        const payload = JSON.parse(body || '{}');
        const actualPayload = payload.payload || payload;
        const config = payload.config || {};
        const repoFull = actualPayload.repository?.full_name || process.env.REPOSITORY_NAME;
        const [owner, repo] = (repoFull || '').split('/');
        const githubToken = process.env.GITHUB_TOKEN || config?.installationToken;
        if (!owner || !repo)
            return sendJson(res, 400, { success: false, message: 'Missing repository info' });
        if (!actualPayload.issue || !actualPayload.issue.number)
            return sendJson(res, 400, { success: false, message: 'Missing issue info' });
        const issueContext = {
            issueId: String(actualPayload.issue.id || actualPayload.issue.number),
            issueNumber: String(actualPayload.issue.number),
            title: String(actualPayload.issue.title || ''),
            description: String(actualPayload.issue.body || ''),
            labels: Array.isArray(actualPayload.issue.labels) ? actualPayload.issue.labels.map((l) => (typeof l === 'string' ? l : l.name)).filter(Boolean) : [],
            repositoryUrl: actualPayload.repository?.clone_url || `https://github.com/${repoFull}.git`,
            repositoryName: repoFull || `${owner}/${repo}`,
            author: String(actualPayload.issue.user?.login || 'unknown')
        };
        const result = await processIssue(issueContext, githubToken);
        const duration = Date.now() - startTime;
        logWithContext('PROCESS', 'Issue processing completed', {
            success: result.success,
            durationMs: duration,
            durationSeconds: Math.round(duration / 1000)
        });
        return sendJson(res, result.success ? 200 : 500, result);
    }
    catch (error) {
        const duration = Date.now() - startTime;
        logWithContext('PROCESS', 'Error processing issue', {
            error: error.message,
            durationMs: duration,
            durationSeconds: Math.round(duration / 1000)
        });
        return sendJson(res, 500, { success: false, message: error.message });
    }
}
function sendJson(res, status, obj) {
    res.writeHead(status, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify(obj, null, 2));
}
async function acpJsonRpcHandler(req, res) {
    try {
        logWithContext('ACP-HTTP', 'Processing JSON-RPC request');
        const body = await getRequestBody(req);
        const jsonRpcRequest = JSON.parse(body || '{}');
        logWithContext('ACP-HTTP', 'JSON-RPC request', {
            method: jsonRpcRequest.method,
            id: jsonRpcRequest.id,
            hasParams: !!jsonRpcRequest.params
        });
        // Import ACP handlers dynamically to avoid circular dependencies
        const { ACPHandlers } = await import('./handlers/acp-handlers.js');
        let result;
        let error = null;
        try {
            // Route to appropriate ACP handler based on method
            const handler = ACPHandlers[jsonRpcRequest.method];
            if (!handler) {
                error = {
                    code: -32601,
                    message: `Method not found: ${jsonRpcRequest.method}`,
                    data: { availableMethods: Object.keys(ACPHandlers) }
                };
            }
            else {
                // Create a proper RequestContext for the handlers
                const requestContext = {
                    requestId: jsonRpcRequest.id,
                    timestamp: Date.now(),
                    metadata: {
                        bridge: 'http',
                        containerInstance: INSTANCE_ID
                    }
                };
                // Create notification sender function (optional for HTTP mode)
                const notificationSender = (method, params) => {
                    // In HTTP mode, we can't send real-time notifications
                    // This is a no-op implementation
                    logWithContext('ACP-HTTP', `Notification would be sent: ${method}`, params);
                };
                // Call the handler with proper parameters based on method signature
                if (jsonRpcRequest.method === 'session/prompt') {
                    // handleSessionPrompt expects (params, context, notificationSender)
                    result = await handler(jsonRpcRequest.params, requestContext, notificationSender);
                }
                else {
                    // Other handlers expect (params, context)
                    result = await handler(jsonRpcRequest.params, requestContext);
                }
            }
        }
        catch (handlerError) {
            logWithContext('ACP-HTTP', 'Handler error', {
                method: jsonRpcRequest.method,
                error: handlerError.message
            });
            error = {
                code: -32603,
                message: 'Internal error',
                data: {
                    error: handlerError.message,
                    method: jsonRpcRequest.method
                }
            };
        }
        // Build JSON-RPC response
        const jsonRpcResponse = {
            jsonrpc: '2.0',
            id: jsonRpcRequest.id
        };
        if (error) {
            jsonRpcResponse.error = error;
            logWithContext('ACP-HTTP', 'Sending error response', error);
            return sendJson(res, 500, jsonRpcResponse);
        }
        else {
            jsonRpcResponse.result = result;
            logWithContext('ACP-HTTP', 'Sending success response', {
                method: jsonRpcRequest.method,
                hasResult: !!result
            });
            return sendJson(res, 200, jsonRpcResponse);
        }
    }
    catch (error) {
        logWithContext('ACP-HTTP', 'JSON-RPC processing failed', { error: error.message });
        const errorResponse = {
            jsonrpc: '2.0',
            error: {
                code: -32700,
                message: 'Parse error',
                data: { error: error.message }
            },
            id: null
        };
        return sendJson(res, 400, errorResponse);
    }
}
const server = http.createServer(async (req, res) => {
    const url = new URL(req.url || '/', `http://localhost:${PORT}`);
    if (req.method === 'POST' && url.pathname === '/process-issue') {
        // Process the issue
        await processIssueHandler(req, res);
        // Schedule server shutdown after a brief delay to allow response to complete
        setTimeout(() => {
            logWithContext('SERVER', 'Shutting down after processing issue');
            server.close(() => {
                logWithContext('SERVER', 'Server closed, process will exit');
                process.exit(0);
            });
        }, 1000); // 1 second delay
        return;
    }
    if (req.method === 'POST' && url.pathname === '/acp') {
        // Route to ACP server for JSON-RPC processing
        await acpJsonRpcHandler(req, res);
        return;
    }
    if (req.method === 'GET' && url.pathname === '/health') {
        return sendJson(res, 200, {
            status: 'healthy',
            instance: INSTANCE_ID,
            modes: ['http', 'acp'],
            endpoints: {
                '/process-issue': 'POST - GitHub issue processing',
                '/acp': 'POST - Agent Client Protocol JSON-RPC',
                '/health': 'GET - Health check'
            },
            timestamp: new Date().toISOString()
        });
    }
    return sendJson(res, 404, { success: false, message: 'not found' });
});
// Main startup logic - determine mode and start appropriate server
const runtimeMode = determineRuntimeMode();
if (runtimeMode === 'acp') {
    // ACP stdio mode - use Zed's ACP agent implementation
    const isTestEnv = process.env.NODE_ENV === 'test';
    if (!isTestEnv) {
        console.error(`[CONTAINER] Starting in ACP mode with Zed agent (instance: ${INSTANCE_ID})`);
        console.error(`[CONTAINER] Process PID: ${process.pid}`);
        console.error(`[CONTAINER] Node version: ${process.version}`);
        console.error(`[CONTAINER] Working directory: ${process.cwd()}`);
        console.error(`[CONTAINER] ANTHROPIC_API_KEY present: ${!!process.env.ANTHROPIC_API_KEY}`);
    }
    // Use Zed's ACP agent for stdout/stdin communication
    runAcp();
    if (!isTestEnv) {
        console.error('[CONTAINER] Zed ACP agent started, ready for JSON-RPC communication over stdio');
    }
}
else if (runtimeMode === 'generic-acp') {
    // Generic ACP mode - for client-server agent communication
    const isTestEnv = process.env.NODE_ENV === 'test';
    if (!isTestEnv) {
        console.error(`[CONTAINER] Starting in Generic ACP mode (instance: ${INSTANCE_ID})`);
        console.error(`[CONTAINER] Process PID: ${process.pid}`);
        console.error(`[CONTAINER] Node version: ${process.version}`);
        console.error(`[CONTAINER] Working directory: ${process.cwd()}`);
        console.error(`[CONTAINER] ANTHROPIC_API_KEY present: ${!!process.env.ANTHROPIC_API_KEY}`);
    }
    // Use generic ACP agent for any client system
    runGenericAcp({
        requireAuth: process.env.REQUIRE_CLIENT_AUTH === 'true'
    });
    if (!isTestEnv) {
        console.error('[CONTAINER] Generic ACP agent started, ready for client-server communication over stdio');
    }
}
else {
    // HTTP server mode (existing behavior)
    console.error(`[CONTAINER] Starting in HTTP mode (instance: ${INSTANCE_ID})`);
    server.listen(PORT, '0.0.0.0', () => {
        logWithContext('SERVER', 'Started', { port: PORT, instance: INSTANCE_ID });
    });
}
