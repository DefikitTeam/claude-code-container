import http from 'node:http';
import { URL } from 'node:url';
import { promises as fs } from 'node:fs';
import path from 'node:path';
import os from 'node:os';
import simpleGit from 'simple-git';
import { execFile } from 'node:child_process';
import { promisify } from 'node:util';
import dotenv from 'dotenv';
import { query } from '@anthropic-ai/claude-code';
import { ContainerGitHubClient } from './github_client.js';
dotenv.config();
const PORT = parseInt(process.env.PORT || '8080', 10);
const INSTANCE_ID = process.env.CONTAINER_ID || 'unknown';
function logWithContext(context, message, data) {
    const ts = new Date().toISOString();
    if (data)
        console.log(`[${ts}] [${context}] ${message}`, JSON.stringify(data, null, 2));
    else
        console.log(`[${ts}] [${context}] ${message}`);
}
const pExecFile = promisify(execFile);
async function checkRuntime() {
    const out = {
        node: process.version,
        apiKey: !!process.env.ANTHROPIC_API_KEY,
        githubToken: !!process.env.GITHUB_TOKEN
    };
    try {
        const { stdout } = await pExecFile('git', ['--version']);
        out.git = stdout.trim();
    }
    catch { }
    try {
        const { stdout } = await pExecFile('bash', ['--version']);
        out.bash = stdout.split('\n')[0].trim();
    }
    catch { }
    logWithContext('RUNTIME', 'Environment check', out);
    return out;
}
function prepareClaudePrompt(issueContext, repoSummary = null) {
    return `
You are working on GitHub issue #${issueContext.issueNumber}: "${issueContext.title}"

Issue Description:
${issueContext.description}

Labels: ${issueContext.labels.join(', ')}
Author: ${issueContext.author}

The repository has been cloned to your current working directory. Please:
1. Explore the codebase to understand the structure and relevant files
2. Analyze the issue requirements thoroughly
3. Implement a solution that addresses the issue
4. Write appropriate tests if needed
5. Ensure code quality and consistency with existing patterns

**IMPORTANT: If you make any file changes, please create a file called '.claude-pr-summary.md' in the root directory with a concise summary (1-3 sentences) of what changes you made and why. This will be used for the pull request description.**

Work step by step and provide clear explanations of your approach.
${repoSummary ? `\n\nRepository summary:\n${repoSummary}` : ''}
`;
}
function getMessageText(message) {
    // @ts-ignore
    if (typeof message.text === 'string')
        return message.text;
    // @ts-ignore
    if (typeof message.content === 'string')
        return message.content;
    // @ts-ignore
    if (Array.isArray(message.content))
        return message.content.map((c) => (c.text || JSON.stringify(c))).join('\n');
    return JSON.stringify(message);
}
async function detectGitChanges(workspaceDir) {
    const git = simpleGit(workspaceDir);
    try {
        const status = await git.status();
        return !status.isClean();
    }
    catch (e) {
        logWithContext('GIT', 'detectGitChanges failed', { workspaceDir, error: e.message });
        return false;
    }
}
async function createFeatureBranchCommitAndPush(workspaceDir, branchName, message) {
    const git = simpleGit(workspaceDir);
    await git.checkoutLocalBranch(branchName);
    await git.add('.');
    const result = await git.commit(message);
    await git.push('origin', branchName, ['--set-upstream']);
    return result.commit;
}
async function readPRSummary(workspaceDir) {
    const summaryPath = path.join(workspaceDir, '.claude-pr-summary.md');
    try {
        const content = await fs.readFile(summaryPath, 'utf8');
        return content.trim();
    }
    catch {
        return null;
    }
}
function generatePRBody(prSummary, solution, issueNumber) {
    let body = '';
    if (prSummary)
        body = prSummary.trim();
    else
        body = 'Automated fix generated by Claude Code.';
    body += `\n\n---\nFixes #${issueNumber}\n\nðŸ¤– This pull request was generated automatically by Claude Code.`;
    body += `\n\n\n**Solution proposed:**\n${solution}`;
    return body;
}
async function getRequestBody(req) {
    let body = '';
    for await (const chunk of req)
        body += chunk.toString();
    return body;
}
async function setupWorkspace(cloneUrl, githubToken) {
    const workspaceDir = path.join(os.tmpdir(), `claude-workspace-${Date.now()}`);
    await fs.mkdir(workspaceDir, { recursive: true });
    logWithContext('WORKSPACE', 'Cloning repository', { cloneUrl, workspaceDir });
    const git = simpleGit();
    const token = githubToken || process.env.GITHUB_TOKEN;
    const authenticated = token ? cloneUrl.replace('https://github.com/', `https://x-access-token:${token}@github.com/`) : cloneUrl;
    await git.clone(authenticated, workspaceDir, ['--depth', '1']);
    // Configure Git user identity in the workspace
    const workspaceGit = simpleGit(workspaceDir);
    await workspaceGit.addConfig('user.name', 'Claude Code Bot');
    await workspaceGit.addConfig('user.email', 'claude-code@anthropic.com');
    logWithContext('WORKSPACE', 'Git user identity configured');
    return workspaceDir;
}
async function cleanupWorkspace(dir) {
    try {
        await fs.rm(dir, { recursive: true, force: true });
        logWithContext('WORKSPACE', 'Cleaned up', { dir });
    }
    catch (e) {
        logWithContext('WORKSPACE', 'Cleanup failed', { dir, error: e.message });
    }
}
async function processIssue(issueContext, githubToken) {
    const results = [];
    let turnCount = 0;
    try {
        // Ensure runtime dependencies are available
        const rt = await checkRuntime();
        if (!rt.apiKey) {
            return { success: false, message: 'Missing Anthropic API key (ANTHROPIC_API_KEY)' };
        }
        if (!rt.git) {
            return { success: false, message: 'git is not available in the container PATH' };
        }
        const workspaceDir = await setupWorkspace(issueContext.repositoryUrl, githubToken);
        const [owner, repo] = issueContext.repositoryName.split('/');
        const githubClient = new ContainerGitHubClient(githubToken, owner, repo);
        const prompt = prepareClaudePrompt(issueContext);
        logWithContext('ISSUE_PROCESSOR', 'Prompt prepared', { length: prompt.length });
        const originalCwd = process.cwd();
        process.chdir(workspaceDir);
        let solution = 'No solution generated.';
        try {
            // Enable verbose SDK debug logs if not already set
            if (!process.env.DEBUG)
                process.env.DEBUG = 'claude-code:*';
            logWithContext('CLAUDE', 'Starting Claude Code SDK', { apiKeyExists: !!process.env.ANTHROPIC_API_KEY });
            for await (const message of query({ prompt, options: { permissionMode: 'bypassPermissions' } })) {
                turnCount++;
                results.push(message);
                logWithContext('CLAUDE', `Turn ${turnCount}`, { type: message.type });
            }
            solution = results.length > 0 ? getMessageText(results[results.length - 1]) : 'No solution generated.';
        }
        catch (sdkError) {
            logWithContext('CLAUDE', 'Claude Code SDK error', { error: sdkError?.message || String(sdkError), stack: sdkError?.stack });
            try {
                await githubClient.createComment(parseInt(issueContext.issueNumber), [
                    'âš ï¸ Claude Code failed in the container.',
                    '',
                    `Error: ${sdkError?.message || String(sdkError)}`,
                    '',
                    'Checklist:',
                    `- ANTHROPIC_API_KEY present: ${rt.apiKey ? 'yes' : 'no'}`,
                    `- git available: ${rt.git ? rt.git : 'no'}`,
                    `- bash available: ${rt.bash ? rt.bash : 'no'}`,
                    `- node: ${rt.node}`,
                    '',
                    'Please check container logs for claude-code debug output (DEBUG=claude-code:*).'
                ].join('\n'));
            }
            catch (commentErr) {
                logWithContext('CLAUDE', 'Failed to post SDK error comment', { error: commentErr.message });
            }
            await cleanupWorkspace(workspaceDir);
            return { success: false, message: 'Claude Code process exited with code 1' };
        }
        finally {
            process.chdir(originalCwd);
        }
        const hasChanges = await detectGitChanges(workspaceDir);
        if (hasChanges) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').replace(/T/g, '-').split('.')[0];
            const branchName = `claude-code/issue-${issueContext.issueNumber}-${timestamp}`;
            await createFeatureBranchCommitAndPush(workspaceDir, branchName, `Fix issue #${issueContext.issueNumber}: ${issueContext.title}`);
            const prSummary = await readPRSummary(workspaceDir);
            const repoInfo = await githubClient.getRepository();
            const prTitle = prSummary ? prSummary.split('\n')[0].trim() : `Fix issue #${issueContext.issueNumber}`;
            const prBody = generatePRBody(prSummary, solution, issueContext.issueNumber);
            const pullRequest = await githubClient.createPullRequest(prTitle, prBody, branchName, repoInfo.default_branch);
            await cleanupWorkspace(workspaceDir);
            await githubClient.createComment(parseInt(issueContext.issueNumber), `ðŸ”§ Created PR: ${pullRequest.html_url}`);
            return { success: true, message: 'Pull request created', pullRequestUrl: pullRequest.html_url };
        }
        else {
            await githubClient.createComment(parseInt(issueContext.issueNumber), `${solution}\n\n---\nðŸ¤– Generated with Claude Code`);
            await cleanupWorkspace(workspaceDir);
            return { success: true, message: 'Comment posted (no file changes)' };
        }
    }
    catch (error) {
        return { success: false, message: 'Processing failed', error: error.message };
    }
}
async function processIssueHandler(req, res) {
    try {
        const body = await getRequestBody(req);
        const payload = JSON.parse(body || '{}');
        const actualPayload = payload.payload || payload;
        const config = payload.config || {};
        const repoFull = actualPayload.repository?.full_name || process.env.REPOSITORY_NAME;
        const [owner, repo] = (repoFull || '').split('/');
        const githubToken = process.env.GITHUB_TOKEN || config?.installationToken;
        if (!owner || !repo)
            return sendJson(res, 400, { success: false, message: 'Missing repository info' });
        if (!actualPayload.issue || !actualPayload.issue.number)
            return sendJson(res, 400, { success: false, message: 'Missing issue info' });
        const issueContext = {
            issueId: String(actualPayload.issue.id || actualPayload.issue.number),
            issueNumber: String(actualPayload.issue.number),
            title: String(actualPayload.issue.title || ''),
            description: String(actualPayload.issue.body || ''),
            labels: Array.isArray(actualPayload.issue.labels) ? actualPayload.issue.labels.map((l) => (typeof l === 'string' ? l : l.name)).filter(Boolean) : [],
            repositoryUrl: actualPayload.repository?.clone_url || `https://github.com/${repoFull}.git`,
            repositoryName: repoFull || `${owner}/${repo}`,
            author: String(actualPayload.issue.user?.login || 'unknown')
        };
        const result = await processIssue(issueContext, githubToken);
        return sendJson(res, result.success ? 200 : 500, result);
    }
    catch (error) {
        logWithContext('PROCESS', 'Error processing issue', { error: error.message });
        return sendJson(res, 500, { success: false, message: error.message });
    }
}
function sendJson(res, status, obj) {
    res.writeHead(status, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify(obj, null, 2));
}
const server = http.createServer(async (req, res) => {
    const url = new URL(req.url || '/', `http://localhost:${PORT}`);
    if (req.method === 'POST' && url.pathname === '/process-issue')
        return processIssueHandler(req, res);
    if (req.method === 'GET' && url.pathname === '/health')
        return sendJson(res, 200, { status: 'healthy', instance: INSTANCE_ID });
    return sendJson(res, 404, { success: false, message: 'not found' });
});
server.listen(PORT, '0.0.0.0', () => {
    logWithContext('SERVER', 'Started', { port: PORT, instance: INSTANCE_ID });
});
