import http from 'node:http';
import { URL } from 'node:url';
import { promises as fs } from 'node:fs';
import path from 'node:path';
import os from 'node:os';
import simpleGit from 'simple-git';
import { execFile } from 'node:child_process';
import { promisify } from 'node:util';
import dotenv from 'dotenv';
import { query, type SDKMessage } from '@anthropic-ai/claude-code';
import { ContainerGitHubClient } from './github_client.js';

dotenv.config();

const PORT = parseInt(process.env.PORT || '8080', 10);
const INSTANCE_ID = process.env.CONTAINER_ID || 'unknown';

interface IssueContext {
  issueId: string;
  issueNumber: string;
  title: string;
  description: string;
  labels: string[];
  repositoryUrl: string;
  repositoryName: string;
  author: string;
}

interface ContainerResponse {
  success: boolean;
  message: string;
  pullRequestUrl?: string;
  error?: string;
}

function logWithContext(context: string, message: string, data?: any) {
  const ts = new Date().toISOString();
  if (data) console.log(`[${ts}] [${context}] ${message}`, JSON.stringify(data, null, 2)); else console.log(`[${ts}] [${context}] ${message}`);
}

const pExecFile = promisify(execFile);

async function checkRuntime(): Promise<{ git?: string; bash?: string; node: string; apiKey: boolean; githubToken: boolean }> {
  const out: { git?: string; bash?: string; node: string; apiKey: boolean; githubToken: boolean } = {
    node: process.version,
    apiKey: !!process.env.ANTHROPIC_API_KEY,
    githubToken: !!process.env.GITHUB_TOKEN
  };
  try {
    const { stdout } = await pExecFile('git', ['--version']);
    out.git = stdout.trim();
  } catch {}
  try {
    const { stdout } = await pExecFile('bash', ['--version']);
    out.bash = stdout.split('\n')[0].trim();
  } catch {}
  logWithContext('RUNTIME', 'Environment check', out);
  return out;
}

function prepareClaudePrompt(issueContext: IssueContext, repoSummary: string | null = null): string {
  return `
You are working on GitHub issue #${issueContext.issueNumber}: "${issueContext.title}"

Issue Description:
${issueContext.description}

Labels: ${issueContext.labels.join(', ')}
Author: ${issueContext.author}

The repository has been cloned to your current working directory. Please:
1. Explore the codebase to understand the structure and relevant files
2. Analyze the issue requirements thoroughly
3. Implement a solution that addresses the issue
4. Write appropriate tests if needed
5. Ensure code quality and consistency with existing patterns

**IMPORTANT: If you make any file changes, please create a file called '.claude-pr-summary.md' in the root directory with a concise summary (1-3 sentences) of what changes you made and why. This will be used for the pull request description.**

Work step by step and provide clear explanations of your approach.
${repoSummary ? `\n\nRepository summary:\n${repoSummary}` : ''}
`;
}

function getMessageText(message: SDKMessage): string {
  // @ts-ignore
  if (typeof message.text === 'string') return message.text;
  // @ts-ignore
  if (typeof message.content === 'string') return message.content;
  // @ts-ignore
  if (Array.isArray(message.content)) return message.content.map((c: any) => (c.text || JSON.stringify(c))).join('\n');
  return JSON.stringify(message);
}

async function detectGitChanges(workspaceDir: string): Promise<boolean> {
  const git = simpleGit(workspaceDir);
  try {
    const status = await git.status();
    return !status.isClean();
  } catch (e) {
    logWithContext('GIT', 'detectGitChanges failed', { workspaceDir, error: (e as Error).message });
    return false;
  }
}

async function createFeatureBranchCommitAndPush(workspaceDir: string, branchName: string, message: string): Promise<string> {
  const git = simpleGit(workspaceDir);
  await git.checkoutLocalBranch(branchName);
  await git.add('.');
  const result = await git.commit(message);
  await git.push('origin', branchName, ['--set-upstream']);
  return result.commit;
}

async function readPRSummary(workspaceDir: string): Promise<string | null> {
  const summaryPath = path.join(workspaceDir, '.claude-pr-summary.md');
  try {
    const content = await fs.readFile(summaryPath, 'utf8');
    return content.trim();
  } catch {
    return null;
  }
}

function generatePRBody(prSummary: string | null, solution: string, issueNumber: string): string {
  let body = '';
  if (prSummary) body = prSummary.trim(); else body = 'Automated fix generated by Claude Code.';
  body += `\n\n---\nFixes #${issueNumber}\n\nü§ñ This pull request was generated automatically by Claude Code.`;
  body += `\n\n\n**Solution proposed:**\n${solution}`;
  return body;
}

async function getRequestBody(req: http.IncomingMessage): Promise<string> {
  let body = '';
  for await (const chunk of req) body += chunk.toString();
  return body;
}

async function setupWorkspace(cloneUrl: string, githubToken?: string): Promise<string> {
  const workspaceDir = path.join(os.tmpdir(), `claude-workspace-${Date.now()}`);
  await fs.mkdir(workspaceDir, { recursive: true });
  logWithContext('WORKSPACE', 'Cloning repository', { cloneUrl, workspaceDir });

  const git = simpleGit();
  const token = githubToken || process.env.GITHUB_TOKEN;
  const authenticated = token ? cloneUrl.replace('https://github.com/', `https://x-access-token:${token}@github.com/`) : cloneUrl;

  await git.clone(authenticated, workspaceDir, ['--depth', '1']);
  
  // Configure Git user identity in the workspace
  const workspaceGit = simpleGit(workspaceDir);
  await workspaceGit.addConfig('user.name', 'Claude Code Bot');
  await workspaceGit.addConfig('user.email', 'claude-code@anthropic.com');
  logWithContext('WORKSPACE', 'Git user identity configured');
  
  return workspaceDir;
}

async function cleanupWorkspace(dir: string) {
  try {
    await fs.rm(dir, { recursive: true, force: true });
    logWithContext('WORKSPACE', 'Cleaned up', { dir });
  } catch (e) {
    logWithContext('WORKSPACE', 'Cleanup failed', { dir, error: (e as Error).message });
  }
}

async function processIssue(issueContext: IssueContext, githubToken: string): Promise<ContainerResponse> {
  const results: SDKMessage[] = [];
  let turnCount = 0;

  try {
    // Ensure runtime dependencies are available
    const rt = await checkRuntime();
    if (!rt.apiKey) {
      return { success: false, message: 'Missing Anthropic API key (ANTHROPIC_API_KEY)' };
    }
    if (!rt.git) {
      return { success: false, message: 'git is not available in the container PATH' };
    }

    const workspaceDir = await setupWorkspace(issueContext.repositoryUrl, githubToken);
    const [owner, repo] = issueContext.repositoryName.split('/');
    const githubClient = new ContainerGitHubClient(githubToken, owner, repo);

    const prompt = prepareClaudePrompt(issueContext);
    logWithContext('ISSUE_PROCESSOR', 'Prompt prepared', { length: prompt.length });

    const originalCwd = process.cwd();
    process.chdir(workspaceDir);
    let solution = 'No solution generated.';
    try {
      // Enable verbose SDK debug logs if not already set
      if (!process.env.DEBUG) process.env.DEBUG = 'claude-code:*';
      logWithContext('CLAUDE', 'Starting Claude Code SDK', { apiKeyExists: !!process.env.ANTHROPIC_API_KEY });
      for await (const message of query({ prompt, options: { permissionMode: 'bypassPermissions' } })) {
        turnCount++;
        results.push(message as SDKMessage);
        logWithContext('CLAUDE', `Turn ${turnCount}`, { type: (message as any).type });
      }
      solution = results.length > 0 ? getMessageText(results[results.length - 1]) : 'No solution generated.';
    } catch (sdkError: any) {
      logWithContext('CLAUDE', 'Claude Code SDK error', { error: sdkError?.message || String(sdkError), stack: sdkError?.stack });
      try {
        await githubClient.createComment(
          parseInt(issueContext.issueNumber),
          [
            '‚ö†Ô∏è Claude Code failed in the container.',
            '',
            `Error: ${sdkError?.message || String(sdkError)}`,
            '',
            'Checklist:',
            `- ANTHROPIC_API_KEY present: ${rt.apiKey ? 'yes' : 'no'}`,
            `- git available: ${rt.git ? rt.git : 'no'}`,
            `- bash available: ${rt.bash ? rt.bash : 'no'}`,
            `- node: ${rt.node}`,
            '',
            'Please check container logs for claude-code debug output (DEBUG=claude-code:*).'
          ].join('\n')
        );
      } catch (commentErr: any) {
        logWithContext('CLAUDE', 'Failed to post SDK error comment', { error: commentErr.message });
      }
      await cleanupWorkspace(workspaceDir);
      return { success: false, message: 'Claude Code process exited with code 1' };
    } finally {
      process.chdir(originalCwd);
    }

    const hasChanges = await detectGitChanges(workspaceDir);

    if (hasChanges) {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').replace(/T/g, '-').split('.')[0];
      const branchName = `claude-code/issue-${issueContext.issueNumber}-${timestamp}`;
      await createFeatureBranchCommitAndPush(workspaceDir, branchName, `Fix issue #${issueContext.issueNumber}: ${issueContext.title}`);

      const prSummary = await readPRSummary(workspaceDir);
      const repoInfo = await githubClient.getRepository();
      const prTitle = prSummary ? prSummary.split('\n')[0].trim() : `Fix issue #${issueContext.issueNumber}`;
      const prBody = generatePRBody(prSummary, solution, issueContext.issueNumber);

      const pullRequest = await githubClient.createPullRequest(prTitle, prBody, branchName, repoInfo.default_branch);
      await cleanupWorkspace(workspaceDir);

      await githubClient.createComment(parseInt(issueContext.issueNumber), `üîß Created PR: ${pullRequest.html_url}`);

      return { success: true, message: 'Pull request created', pullRequestUrl: pullRequest.html_url };
    } else {
      await githubClient.createComment(parseInt(issueContext.issueNumber), `${solution}\n\n---\nü§ñ Generated with Claude Code`);
      await cleanupWorkspace(workspaceDir);
      return { success: true, message: 'Comment posted (no file changes)' };
    }
  } catch (error: any) {
    return { success: false, message: 'Processing failed', error: error.message };
  }
}

async function processIssueHandler(req: http.IncomingMessage, res: http.ServerResponse) {
  const startTime = Date.now();
  logWithContext('PROCESS', 'Starting issue processing', { timestamp: new Date().toISOString() });
  
  try {
    const body = await getRequestBody(req);
    const payload = JSON.parse(body || '{}');

    const actualPayload = payload.payload || payload;
    const config = payload.config || {};

    const repoFull = actualPayload.repository?.full_name || process.env.REPOSITORY_NAME;
    const [owner, repo] = (repoFull || '').split('/');
    const githubToken = process.env.GITHUB_TOKEN || config?.installationToken;

    if (!owner || !repo) return sendJson(res, 400, { success: false, message: 'Missing repository info' });
    if (!actualPayload.issue || !actualPayload.issue.number) return sendJson(res, 400, { success: false, message: 'Missing issue info' });

    const issueContext: IssueContext = {
      issueId: String(actualPayload.issue.id || actualPayload.issue.number),
      issueNumber: String(actualPayload.issue.number),
      title: String(actualPayload.issue.title || ''),
      description: String(actualPayload.issue.body || ''),
      labels: Array.isArray(actualPayload.issue.labels) ? actualPayload.issue.labels.map((l: any) => (typeof l === 'string' ? l : l.name)).filter(Boolean) : [],
      repositoryUrl: actualPayload.repository?.clone_url || `https://github.com/${repoFull}.git`,
      repositoryName: repoFull || `${owner}/${repo}`,
      author: String(actualPayload.issue.user?.login || 'unknown')
    };

    const result = await processIssue(issueContext, githubToken);
    
    const duration = Date.now() - startTime;
    logWithContext('PROCESS', 'Issue processing completed', { 
      success: result.success, 
      durationMs: duration,
      durationSeconds: Math.round(duration / 1000)
    });
    
    return sendJson(res, result.success ? 200 : 500, result);
  } catch (error: any) {
    const duration = Date.now() - startTime;
    logWithContext('PROCESS', 'Error processing issue', { 
      error: error.message, 
      durationMs: duration,
      durationSeconds: Math.round(duration / 1000)
    });
    return sendJson(res, 500, { success: false, message: error.message });
  }
}

function sendJson(res: http.ServerResponse, status: number, obj: any) {
  res.writeHead(status, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify(obj, null, 2));
}

const server = http.createServer(async (req, res) => {
  const url = new URL(req.url || '/', `http://localhost:${PORT}`);
  if (req.method === 'POST' && url.pathname === '/process-issue') return processIssueHandler(req, res);
  if (req.method === 'GET' && url.pathname === '/health') return sendJson(res, 200, { status: 'healthy', instance: INSTANCE_ID });
  return sendJson(res, 404, { success: false, message: 'not found' });
});

server.listen(PORT, '0.0.0.0', () => {
  logWithContext('SERVER', 'Started', { port: PORT, instance: INSTANCE_ID });
});

